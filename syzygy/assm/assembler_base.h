// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file declares implementation classes to generate assembly code.
// The API to the assembler is intentionally very close to the API exposed
// by the V8 assembler (see src/ia32/assembler-ia32.* in V8 repository).

#ifndef SYZYGY_ASSM_ASSEMBLER_BASE_H_
#define SYZYGY_ASSM_ASSEMBLER_BASE_H_

#include "syzygy/assm/cond.h"
#include "syzygy/assm/operand_base.h"
#include "syzygy/assm/register.h"
#include "syzygy/assm/value_base.h"

namespace assm {

// The reference sizes the assembler supports coincides with register sizes.
typedef RegisterSize ReferenceSize;

// The assembler takes care of maintaining an output location (address), and
// generating a stream of bytes and references as instructions are assembled.
template <class ReferenceType>
class AssemblerBase {
 public:
  // TODO(siggi): Remove these typedefs and use the Displacement, Immediate,
  //     Operand typedefs instead.
  typedef DisplacementBase<ReferenceType> DisplacementImpl;
  typedef ImmediateBase<ReferenceType> ImmediateImpl;
  typedef OperandBase<ReferenceType> OperandImpl;

  typedef DisplacementBase<ReferenceType> Displacement;
  typedef ImmediateBase<ReferenceType> Immediate;
  typedef OperandBase<ReferenceType> Operand;

  // Tracks a single embedded reference in the instruction.
  struct ReferenceInfo {
    size_t offset;
    ReferenceType reference;
    ReferenceSize size;
    bool pc_relative;
  };

  // The assembler pushes instructions and references to
  // one of these for serialization.
  class InstructionSerializer {
   public:
    virtual void AppendInstruction(uint32 location,
                                   const uint8* bytes,
                                   size_t num_bytes,
                                   const ReferenceInfo* refs,
                                   size_t num_refs) = 0;
  };

  // Constructs an assembler that assembles to @p delegate
  // starting at @p location.
  AssemblerBase(uint32 location, InstructionSerializer* serializer);

  // @name Accessors.
  // @{
  uint32 location() const { return location_; }
  void set_location(uint32 location) { location_ = location; }
  // @}

  // Emits one or more NOP instructions, their total length being @p size
  // bytes.
  // @param size The number of bytes of NOPs to generate.
  // @note For a generated NOP sequence of optimal performance it is best to
  //     call nop once rather than successively (ie: the NOP sequence generated
  //     by nop(x) nop(y) may perform worse than that generated by nop(x + y).
  void nop(size_t size);

  // @name Call instructions.
  // @{
  void call(const ImmediateImpl& dst);
  void call(const OperandImpl& dst);
  // @}

 protected:
  // @name Control flow instructions.
  // These instructions are protected, as they're not appropriate to expose
  // for all assembler subclasses.
  // @{
  void j(ConditionCode cc, const ImmediateImpl& dst);
  void jecxz(const ImmediateImpl& dst);
  void jmp(const ImmediateImpl& dst);
  void jmp(const OperandImpl& dst);
  void l(LoopCode lc, const ImmediateImpl& dst);

 public:
  void ret();
  void ret(uint16 n);
  // @}

  // @name Set flags.
  // @{
  void set(ConditionCode cc, const Register32& src);
  // @}

  // @name Byte mov varieties.
  // @{
  void mov_b(const OperandImpl& dst, const ImmediateImpl& src);
  void movzx_b(const Register32& dst, const OperandImpl& src);
  // @}

  // @name Double-word mov varieties.
  // @{
  void mov(const Register32& dst, const Register32& src);
  void mov(const Register32& dst, const OperandImpl& src);
  void mov(const OperandImpl& dst, const Register32& src);
  void mov(const Register32& dst, const ImmediateImpl& src);
  void mov(const OperandImpl& dst, const ImmediateImpl& src);
  void mov_fs(const Register32& dst, const OperandImpl& src);
  void mov_fs(const OperandImpl& dst, const Register32& src);
  // @}

  // @name Load effective address.
  void lea(const Register32& dst, const OperandImpl& src);

  // @name Stack manipulation.
  // @{
  void push(const Register32& src);
  void push(const ImmediateImpl& src);
  void push(const OperandImpl& src);
  void pushad();

  void pop(const Register32& dst);
  void pop(const OperandImpl& dst);
  void popad();
  // @}

  // @name Flag manipulation.
  // @{
  void pushfd();
  void popfd();
  void lahf();
  void sahf();
  // @}

  // @name Arithmetic operations.
  // @{
  void test(const Register8& dst, const Register8& src);
  void test(const Register8& dst, const ImmediateImpl& src);

  void test(const Register32& dst, const Register32& src);
  void test(const Register32& dst, const OperandImpl& src);
  void test(const OperandImpl& dst, const Register32& src);
  void test(const Register32& dst, const ImmediateImpl& src);
  void test(const OperandImpl& dst, const ImmediateImpl& src);

  void cmp(const Register8& dst, const Register8& src);
  void cmp(const Register8& dst, const ImmediateImpl& src);

  void cmp(const Register32& dst, const Register32& src);
  void cmp(const Register32& dst, const OperandImpl& src);
  void cmp(const OperandImpl& dst, const Register32& src);
  void cmp(const Register32& dst, const ImmediateImpl& src);
  void cmp(const OperandImpl& dst, const ImmediateImpl& src);

  void add(const Register8& dst, const Register8& src);
  void add(const Register8& dst, const ImmediateImpl& src);

  void add(const Register32& dst, const Register32& src);
  void add(const Register32& dst, const OperandImpl& src);
  void add(const OperandImpl& dst, const Register32& src);
  void add(const Register32& dst, const ImmediateImpl& src);
  void add(const OperandImpl& dst, const ImmediateImpl& src);

  void sub(const Register8& dst, const Register8& src);
  void sub(const Register8& dst, const ImmediateImpl& src);

  void sub(const Register32& dst, const Register32& src);
  void sub(const Register32& dst, const OperandImpl& src);
  void sub(const OperandImpl& dst, const Register32& src);
  void sub(const Register32& dst, const ImmediateImpl& src);
  void sub(const OperandImpl& dst, const ImmediateImpl& src);
  // @}

  // @name Shifting operations.
  // @{
  void shl(const Register32& dst, const ImmediateImpl& src);
  void shr(const Register32& dst, const ImmediateImpl& src);
  // @}

  // Exchange contents of two registers.
  // @param dst The destination register.
  // @param src The source register.
  // @note Exchanges involving eax generate shorter byte code.
  // @note This instruction can be used as a primitive for writing
  //     synchronization mechanisms as there is an implicit lock taken
  //     during execution.
  void xchg(const Register32& dst, const Register32& src);
  void xchg(const Register16& dst, const Register16& src);
  void xchg(const Register8& dst, const Register8& src);

  // @name Aliases
  // @{
  void loop(const ImmediateImpl& dst) { l(kLoopOnCounter, dst); }
  void loope(const ImmediateImpl& dst) { l(kLoopOnCounterAndZeroFlag, dst); }
  void loopne(const ImmediateImpl& dst) {
    l(kLoopOnCounterAndNotZeroFlag, dst);
  }
  // @}

 private:
  class InstructionBuffer;

  // @name Nop instruction helpers.
  // @{
  // Each of these corresponds to a basic suggested NOP sequence. They
  // can each be extended by prefixing with 1 or more operand size (0x66)
  // prefixes. These are not exposed directly as the user should simply
  // call 'nop' instead.
  // @param prefix_count The number of operand size prefix bytes to apply.
  void nop1(size_t prefix_count);
  void nop4(size_t prefix_count);
  void nop5(size_t prefix_count);
  void nop7(size_t prefix_count);
  void nop8(size_t prefix_count);
  // @}

  // Output the instruction data in @p instr to our delegate.
  void Output(const InstructionBuffer& instr);

  // Stores the current location of assembly.
  uint32 location_;

  // The delegate we push instructions at.
  InstructionSerializer* serializer_;
};

}  // namespace assm

#include "syzygy/assm/assembler_base_impl.h"

#endif  // SYZYGY_ASSM_ASSEMBLER_BASE_H_
