; Copyright 2015 Google Inc. All Rights Reserved.
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.

; This file is generated by generate_memory_interceptors.py, DO NOT MODIFY.
; Regenerate this file by running syzygy/agent/asan/generate_files.bat.

.386
.MODEL FLAT, C

.CODE

; Allow section and label names to begin with a leading period.
OPTION DOTNAME

; Declare the global shadow memory array that probes refer to.
EXTERN C asan_memory_interceptors_shadow_memory:FAR

; Declare the string checking helper function.
EXTERN C asan_check_strings_memory_accesses:PROC

; Declare the redirect function.
EXTERN C asan_redirect_stub_entry:PROC

; Declare the error handling funtion.
EXTERN C asan_report_bad_memory_access:PROC

; Declares the symbols that this compiland exports.
PUBLIC asan_no_check
PUBLIC asan_string_no_check
PUBLIC asan_redirect_tail
PUBLIC asan_shadow_references
PUBLIC asan_check_1_byte_read_access  ; Probe #0.
PUBLIC asan_check_1_byte_write_access  ; Probe #1.
PUBLIC asan_check_2_byte_read_access  ; Probe #2.
PUBLIC asan_check_2_byte_write_access  ; Probe #3.
PUBLIC asan_check_4_byte_read_access  ; Probe #4.
PUBLIC asan_check_4_byte_write_access  ; Probe #5.
PUBLIC asan_check_8_byte_read_access  ; Probe #6.
PUBLIC asan_check_8_byte_write_access  ; Probe #7.
PUBLIC asan_check_10_byte_read_access  ; Probe #8.
PUBLIC asan_check_10_byte_write_access  ; Probe #9.
PUBLIC asan_check_16_byte_read_access  ; Probe #10.
PUBLIC asan_check_16_byte_write_access  ; Probe #11.
PUBLIC asan_check_32_byte_read_access  ; Probe #12.
PUBLIC asan_check_32_byte_write_access  ; Probe #13.
PUBLIC asan_check_1_byte_read_access_no_flags  ; Probe #14.
PUBLIC asan_check_1_byte_write_access_no_flags  ; Probe #15.
PUBLIC asan_check_2_byte_read_access_no_flags  ; Probe #16.
PUBLIC asan_check_2_byte_write_access_no_flags  ; Probe #17.
PUBLIC asan_check_4_byte_read_access_no_flags  ; Probe #18.
PUBLIC asan_check_4_byte_write_access_no_flags  ; Probe #19.
PUBLIC asan_check_8_byte_read_access_no_flags  ; Probe #20.
PUBLIC asan_check_8_byte_write_access_no_flags  ; Probe #21.
PUBLIC asan_check_10_byte_read_access_no_flags  ; Probe #22.
PUBLIC asan_check_10_byte_write_access_no_flags  ; Probe #23.
PUBLIC asan_check_16_byte_read_access_no_flags  ; Probe #24.
PUBLIC asan_check_16_byte_write_access_no_flags  ; Probe #25.
PUBLIC asan_check_32_byte_read_access_no_flags  ; Probe #26.
PUBLIC asan_check_32_byte_write_access_no_flags  ; Probe #27.
PUBLIC asan_check_repz_4_byte_cmps_access  ; Probe #28.
PUBLIC asan_check_repz_2_byte_cmps_access  ; Probe #29.
PUBLIC asan_check_repz_1_byte_cmps_access  ; Probe #30.
PUBLIC asan_check_4_byte_cmps_access  ; Probe #31.
PUBLIC asan_check_2_byte_cmps_access  ; Probe #32.
PUBLIC asan_check_1_byte_cmps_access  ; Probe #33.
PUBLIC asan_check_repz_4_byte_movs_access  ; Probe #34.
PUBLIC asan_check_repz_2_byte_movs_access  ; Probe #35.
PUBLIC asan_check_repz_1_byte_movs_access  ; Probe #36.
PUBLIC asan_check_4_byte_movs_access  ; Probe #37.
PUBLIC asan_check_2_byte_movs_access  ; Probe #38.
PUBLIC asan_check_1_byte_movs_access  ; Probe #39.
PUBLIC asan_check_repz_4_byte_stos_access  ; Probe #40.
PUBLIC asan_check_repz_2_byte_stos_access  ; Probe #41.
PUBLIC asan_check_repz_1_byte_stos_access  ; Probe #42.
PUBLIC asan_check_4_byte_stos_access  ; Probe #43.
PUBLIC asan_check_2_byte_stos_access  ; Probe #44.
PUBLIC asan_check_1_byte_stos_access  ; Probe #45.

; Create a new text segment to house the memory interceptors.
.probes SEGMENT PAGE PUBLIC READ EXECUTE 'CODE'

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_no_check PROC
  ; Restore EDX.
  mov edx, DWORD PTR[esp + 4]
  ; And return.
  ret 4
asan_no_check ENDP

; No state is saved for string instructions.
ALIGN 16
asan_string_no_check PROC
  ; Just return.
  ret
asan_string_no_check ENDP

; On entry, the address to check is in EDX and the stack has:
; - previous contents of EDX.
; - return address to original caller.
; - return address to redirection stub.
ALIGN 16
asan_redirect_tail PROC
  ; Prologue, save context.
  pushfd
  pushad

  ; Normalize the string operation direction.
  cld

  ; Compute the address of the calling function and push it.
  mov eax, DWORD PTR[esp + 9 * 4]
  sub eax, 5  ; Length of call instruction.
  push eax
  ; Push the original caller's address.
  push DWORD PTR[esp + 11 * 4]
  call asan_redirect_stub_entry
  ; Clean arguments off the stack.
  add esp, 8

  ; Overwrite access_size with the stub to return to.
  mov DWORD PTR[esp + 9 * 4], eax

  ; Restore context.
  popad
  popfd

  ; return to the stashed stub.
  ret
asan_redirect_tail ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_1_byte_read_access PROC  ; Probe #0.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_0
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_0 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_0
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_0 LABEL NEAR
    js report_failure_0
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_0
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_0 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_read_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_1_byte_write_access PROC  ; Probe #1.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_1
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_1 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_1
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_1 LABEL NEAR
    js report_failure_1
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_1
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_1 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_write_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_2_byte_read_access PROC  ; Probe #2.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_2
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_2 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_2
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_2 LABEL NEAR
    js report_failure_2
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_2
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_2 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_read_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_2_byte_write_access PROC  ; Probe #3.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_3 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_3
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_3 LABEL NEAR
    js report_failure_3
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_3
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_3 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_write_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_4_byte_read_access PROC  ; Probe #4.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_4
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_4 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_4
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_4 LABEL NEAR
    js report_failure_4
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_4
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_4 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_read_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_4_byte_write_access PROC  ; Probe #5.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_5
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_5 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_5
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_5 LABEL NEAR
    js report_failure_5
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_5
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_5 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_write_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_8_byte_read_access PROC  ; Probe #6.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_6
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_6 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_6
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_6 LABEL NEAR
    js report_failure_6
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_6
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_6 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_read_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_8_byte_write_access PROC  ; Probe #7.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_7
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_7 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_7
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_7 LABEL NEAR
    js report_failure_7
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_7
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_7 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_write_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_10_byte_read_access PROC  ; Probe #8.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_8
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_8 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_8
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_8 LABEL NEAR
    js report_failure_8
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_8
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_8 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_read_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_10_byte_write_access PROC  ; Probe #9.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_9
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_9 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_9
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_9 LABEL NEAR
    js report_failure_9
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_9
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_9 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_write_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_16_byte_read_access PROC  ; Probe #10.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_10
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_10 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_10
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_10 LABEL NEAR
    js report_failure_10
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_10
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_10 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_read_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_16_byte_write_access PROC  ; Probe #11.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_11
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_11 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_11
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_11 LABEL NEAR
    js report_failure_11
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_11
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_11 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_write_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_32_byte_read_access PROC  ; Probe #12.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_12
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_12 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_12
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_12 LABEL NEAR
    js report_failure_12
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_12
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_12 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_read_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_32_byte_write_access PROC  ; Probe #13.
    ; Save the EFLAGS.
  push eax
  lahf
  seto al
    push edx
  sar edx, 3
  js report_failure_13
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_13 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_13
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_13 LABEL NEAR
    js report_failure_13
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_13
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_13 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_write_access ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_1_byte_read_access_no_flags PROC  ; Probe #14.
    push edx
  sar edx, 3
  js report_failure_14
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_14 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_14
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_14 LABEL NEAR
    js report_failure_14
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_14
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_14 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_read_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_1_byte_write_access_no_flags PROC  ; Probe #15.
    push edx
  sar edx, 3
  js report_failure_15
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_15 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_15
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_15 LABEL NEAR
    js report_failure_15
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_15
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_15 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_write_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_2_byte_read_access_no_flags PROC  ; Probe #16.
    push edx
  sar edx, 3
  js report_failure_16
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_16 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_16
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_16 LABEL NEAR
    js report_failure_16
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_16
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_16 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_read_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_2_byte_write_access_no_flags PROC  ; Probe #17.
    push edx
  sar edx, 3
  js report_failure_17
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_17 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_17
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_17 LABEL NEAR
    js report_failure_17
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_17
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_17 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_write_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_4_byte_read_access_no_flags PROC  ; Probe #18.
    push edx
  sar edx, 3
  js report_failure_18
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_18 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_18
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_18 LABEL NEAR
    js report_failure_18
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_18
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_18 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_read_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_4_byte_write_access_no_flags PROC  ; Probe #19.
    push edx
  sar edx, 3
  js report_failure_19
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_19 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_19
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_19 LABEL NEAR
    js report_failure_19
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_19
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_19 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_write_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_8_byte_read_access_no_flags PROC  ; Probe #20.
    push edx
  sar edx, 3
  js report_failure_20
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_20 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_20
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_20 LABEL NEAR
    js report_failure_20
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_20
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_20 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_read_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_8_byte_write_access_no_flags PROC  ; Probe #21.
    push edx
  sar edx, 3
  js report_failure_21
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_21 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_21
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_21 LABEL NEAR
    js report_failure_21
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_21
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_21 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_write_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_10_byte_read_access_no_flags PROC  ; Probe #22.
    push edx
  sar edx, 3
  js report_failure_22
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_22 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_22
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_22 LABEL NEAR
    js report_failure_22
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_22
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_22 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_read_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_10_byte_write_access_no_flags PROC  ; Probe #23.
    push edx
  sar edx, 3
  js report_failure_23
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_23 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_23
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_23 LABEL NEAR
    js report_failure_23
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_23
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_23 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_write_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_16_byte_read_access_no_flags PROC  ; Probe #24.
    push edx
  sar edx, 3
  js report_failure_24
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_24 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_24
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_24 LABEL NEAR
    js report_failure_24
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_24
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_24 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_read_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_16_byte_write_access_no_flags PROC  ; Probe #25.
    push edx
  sar edx, 3
  js report_failure_25
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_25 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_25
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_25 LABEL NEAR
    js report_failure_25
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_25
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_25 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_write_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_32_byte_read_access_no_flags PROC  ; Probe #26.
    push edx
  sar edx, 3
  js report_failure_26
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_26 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_26
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_26 LABEL NEAR
    js report_failure_26
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_26
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_26 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_read_access_no_flags ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_32_byte_write_access_no_flags PROC  ; Probe #27.
    push edx
  sar edx, 3
  js report_failure_27
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_27 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_27
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_27 LABEL NEAR
    js report_failure_27
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_27
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_27 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
    ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_write_access_no_flags ENDP

ALIGN 16
asan_check_repz_4_byte_cmps_access PROC  ; Probe #28.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_28
  neg ebx
skip_neg_direction_28 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_4_byte_cmps_access ENDP

ALIGN 16
asan_check_repz_2_byte_cmps_access PROC  ; Probe #29.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_29
  neg ebx
skip_neg_direction_29 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_2_byte_cmps_access ENDP

ALIGN 16
asan_check_repz_1_byte_cmps_access PROC  ; Probe #30.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_30
  neg ebx
skip_neg_direction_30 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_1_byte_cmps_access ENDP

ALIGN 16
asan_check_4_byte_cmps_access PROC  ; Probe #31.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_31
  neg ebx
skip_neg_direction_31 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_4_byte_cmps_access ENDP

ALIGN 16
asan_check_2_byte_cmps_access PROC  ; Probe #32.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_32
  neg ebx
skip_neg_direction_32 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_2_byte_cmps_access ENDP

ALIGN 16
asan_check_1_byte_cmps_access PROC  ; Probe #33.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_33
  neg ebx
skip_neg_direction_33 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_1_byte_cmps_access ENDP

ALIGN 16
asan_check_repz_4_byte_movs_access PROC  ; Probe #34.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_34
  neg ebx
skip_neg_direction_34 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_4_byte_movs_access ENDP

ALIGN 16
asan_check_repz_2_byte_movs_access PROC  ; Probe #35.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_35
  neg ebx
skip_neg_direction_35 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_2_byte_movs_access ENDP

ALIGN 16
asan_check_repz_1_byte_movs_access PROC  ; Probe #36.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_36
  neg ebx
skip_neg_direction_36 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_1_byte_movs_access ENDP

ALIGN 16
asan_check_4_byte_movs_access PROC  ; Probe #37.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_37
  neg ebx
skip_neg_direction_37 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_4_byte_movs_access ENDP

ALIGN 16
asan_check_2_byte_movs_access PROC  ; Probe #38.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_38
  neg ebx
skip_neg_direction_38 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_2_byte_movs_access ENDP

ALIGN 16
asan_check_1_byte_movs_access PROC  ; Probe #39.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_39
  neg ebx
skip_neg_direction_39 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_1_byte_movs_access ENDP

ALIGN 16
asan_check_repz_4_byte_stos_access PROC  ; Probe #40.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_40
  neg ebx
skip_neg_direction_40 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_4_byte_stos_access ENDP

ALIGN 16
asan_check_repz_2_byte_stos_access PROC  ; Probe #41.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_41
  neg ebx
skip_neg_direction_41 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_2_byte_stos_access ENDP

ALIGN 16
asan_check_repz_1_byte_stos_access PROC  ; Probe #42.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_42
  neg ebx
skip_neg_direction_42 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_1_byte_stos_access ENDP

ALIGN 16
asan_check_4_byte_stos_access PROC  ; Probe #43.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_43
  neg ebx
skip_neg_direction_43 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_4_byte_stos_access ENDP

ALIGN 16
asan_check_2_byte_stos_access PROC  ; Probe #44.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_44
  neg ebx
skip_neg_direction_44 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_2_byte_stos_access ENDP

ALIGN 16
asan_check_1_byte_stos_access PROC  ; Probe #45.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_45
  neg ebx
skip_neg_direction_45 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_1_byte_stos_access ENDP

.probes ENDS

; Start writing to the read-only .rdata segment.
.rdata SEGMENT PAGE PUBLIC READ 'DATA'

; This is a null-terminated table of pointers to all shadow memory references.
; This is emitted so that the shadow memory pointer may be rewritten at
; runtime by the dynamic RTL.
ALIGN 4
asan_shadow_references LABEL FAR
  DWORD shadow_reference_0 - 4
  DWORD shadow_reference_1 - 4
  DWORD shadow_reference_2 - 4
  DWORD shadow_reference_3 - 4
  DWORD shadow_reference_4 - 4
  DWORD shadow_reference_5 - 4
  DWORD shadow_reference_6 - 4
  DWORD shadow_reference_7 - 4
  DWORD shadow_reference_8 - 4
  DWORD shadow_reference_9 - 4
  DWORD shadow_reference_10 - 4
  DWORD shadow_reference_11 - 4
  DWORD shadow_reference_12 - 4
  DWORD shadow_reference_13 - 4
  DWORD shadow_reference_14 - 4
  DWORD shadow_reference_15 - 4
  DWORD shadow_reference_16 - 4
  DWORD shadow_reference_17 - 4
  DWORD shadow_reference_18 - 4
  DWORD shadow_reference_19 - 4
  DWORD shadow_reference_20 - 4
  DWORD shadow_reference_21 - 4
  DWORD shadow_reference_22 - 4
  DWORD shadow_reference_23 - 4
  DWORD shadow_reference_24 - 4
  DWORD shadow_reference_25 - 4
  DWORD shadow_reference_26 - 4
  DWORD shadow_reference_27 - 4
  DWORD 0

.rdata ENDS

END
