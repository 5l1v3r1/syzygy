// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by generate_memory_interceptors.py, DO NOT MODIFY.


// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_1_byte_read_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 1
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_1_byte_write_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 1
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_2_byte_read_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 2
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_2_byte_write_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 2
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_4_byte_read_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 4
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_4_byte_write_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 4
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_8_byte_read_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 8
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_8_byte_write_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 8
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_10_byte_read_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 10
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_10_byte_write_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 10
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_16_byte_read_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 16
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_16_byte_write_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 16
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_32_byte_read_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 32
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function modifies no other registers,
// in particular it saves and restores EFLAGS.
extern "C" __declspec(naked)
void asan_check_32_byte_write_access() {
  __asm {
    // Save the EFLAGS.
    push eax
    lahf
    seto al
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 8]
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore the EFLAGS.
    add al, 0x7f
    sahf
    pop eax
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 32
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_1_byte_read_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 1
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_1_byte_write_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 1
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_2_byte_read_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 2
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_2_byte_write_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 2
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_4_byte_read_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 4
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_4_byte_write_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 4
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_8_byte_read_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 8
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_8_byte_write_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 8
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_10_byte_read_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 10
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_10_byte_write_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 10
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_16_byte_read_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 16
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_16_byte_write_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 16
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_32_byte_read_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 32
    // Push ARG2: the access type.
    push AsanReadAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

// On entry, the address to check is in in EDX and the previous contents of
// EDX are on stack. On exit the previous contents of EDX have been restored
// and popped off the stack. This function may modify EFLAGS, but preserves
// all other registers.
extern "C" __declspec(naked)
void asan_check_32_byte_write_access_no_flags() {
  __asm {
    push edx
    sar edx, 3
    js report_failure
    movzx edx, BYTE PTR[edx + Shadow::shadow_]
    cmp dl, 0
    jnz check_access_slow
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  check_access_slow:
    js report_failure
    mov dh, BYTE PTR[esp]
    and dh, 7
    cmp dh, dl
    jae report_failure
    add esp, 4
    // Restore original EDX.
    mov edx, DWORD PTR[esp + 4]
    ret 4
  report_failure:
    // Restore memory location in EDX.
    pop edx
    // Restore original value of EDX, and put memory location on stack.
    xchg edx, DWORD PTR[esp + 4]
    // Create an Asan registers context on the stack.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
    add DWORD PTR[esp + 12], 12
    // Push ARG4: the address of Asan context on stack.
    push esp
    // Push ARG3: the access size.
    push 32
    // Push ARG2: the access type.
    push AsanWriteAccess
    // Push ARG1: the memory location.
    push DWORD PTR[esp + 52]
    call agent::asan::ReportBadMemoryAccess
    // Remove 4 x ARG on stack.
    add esp, 16
    // Restore original registers.
    popad
    popfd
    // Return and remove memory location on stack.
    ret 4
  }
}

extern "C" __declspec(naked)
void asan_check_repz_4_byte_cmps_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 4
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 1
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 4
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanReadAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_2_byte_cmps_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 2
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 1
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 2
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanReadAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_1_byte_cmps_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 1
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 1
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 1
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanReadAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_4_byte_cmps_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 4
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 1
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 4
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanReadAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_2_byte_cmps_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 2
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 1
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 2
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanReadAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_1_byte_cmps_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 1
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 1
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 1
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanReadAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_4_byte_movs_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 4
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 4
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_2_byte_movs_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 2
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 2
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_1_byte_movs_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 1
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 1
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_4_byte_movs_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 4
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 4
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_2_byte_movs_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 2
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 2
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_1_byte_movs_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 1
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 1
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanReadAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_4_byte_stos_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 4
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 4
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanUnknownAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_2_byte_stos_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 2
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 2
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanUnknownAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_repz_1_byte_stos_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 1
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 1
    // Push ARG(length), the number of memory accesses.
    push ecx
    // Push ARG(src_access_mode), source access type.
    push AsanUnknownAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_4_byte_stos_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 4
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 4
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanUnknownAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_2_byte_stos_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 2
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 2
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanUnknownAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}

extern "C" __declspec(naked)
void asan_check_1_byte_stos_access() {
  __asm {
    // Prologue, save context.
    pushfd
    pushad
    // Fix the original value of ESP in the Asan registers context.
    // Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
    add DWORD PTR[esp + 12], 8
    // Setup increment in EBX (depends on direction flag in EFLAGS).
    mov ebx, 1
    pushfd
    pop eax
    test eax, 0x400
    jz skip_neg_direction
    neg ebx
  skip_neg_direction:
    // By standard calling convention, direction flag must be forward.
    cld
    // Push ARG(context), the Asan registers context.
    push esp
    // Push ARG(compare), shortcut when memory contents differ.
    push 0
    // Push ARG(increment), increment for EDI/EDI.
    push ebx
    // Push ARG(access_size), the access size.
    push 1
    // Push ARG(length), the number of memory accesses.
    push 1
    // Push ARG(src_access_mode), source access type.
    push AsanUnknownAccess
    // Push ARG(src), the source pointer.
    push esi
    // Push ARG(dst_access_mode), destination access type.
    push AsanWriteAccess
    // Push ARG(dst), the destination pointer.
    push edi
    // Call the generic check strings function.
    call agent::asan::CheckStringsMemoryAccesses
    add esp, 36
    // Epilogue, restore context.
    popad
    popfd
    ret
  }
}
